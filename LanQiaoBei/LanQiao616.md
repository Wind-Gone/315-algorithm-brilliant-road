---
[SCOI2009] 游戏
---

## Problem

> ### 题目描述
>
> **本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。**
>
> X 星球的居民脾气不太好，但好在他们生气的时候唯一的异常举动是：摔手机。
>
> 各大厂商也就纷纷推出各种耐摔型手机。x星球的质监局规定了手机必须经过耐摔测试，并且评定出一个耐摔指数来，之后才允许上市流通。
>
> X 星球有很多高耸入云的高塔，刚好可以用来做耐摔测试。塔的每一层高度都是一样的，与地球上稍有不同的是，他们的第一层不是地面，而是相当于我们的 2楼。
>
> 如果手机从第 7 层扔下去没摔坏，但第 8 层摔坏了，则手机耐摔指 =7。 特别地，如果手机从第 1 层扔下去就坏了，则耐摔指数 =0。 如果到了塔的最高层第 n 层扔没摔坏，则耐摔指数 =n。
>
> 为了减少测试次数，从每个厂家抽样 3 部手机参加测试。
>
> 某次测试的塔高为 1000 层，如果我们总是采用最佳策略，在最坏的运气下最多需要测试多少次才能确定手机的耐摔指数呢？
>
> 请填写这个最多测试次数。
>
> ### 运行限制
>
> - 最大运行时间：1s
> - 最大运行内存: 128M

## Tag

> - 动归
> - 思维题

## Solution

> - 这道题乍看觉得莫名奇怪，一句“总用最佳策略，在最坏的运气下最多需要测试多少次”就让人很懵，不过很容易让人找到一点灵感的是，从简单的例子出发可能会比较方便把握题意
>
>   - 如果只有一个手机，最坏的运气肯定意味着如果有N层，就需要N次尝试
>
>   - 如果有两个手机的话，很直观的思维就是我们可以把N层分成两部分，一部分一部分测试，比如说如果在第K层高楼摔下，则应该有如下几种情形：
>
>     - 没摔坏，则需要向上层继续尝试（level-k），同时手机数不用减1
>     - 摔坏了，则手机数-1，向下层尝试（k-1）
>
>   - 用一个dp\[i][j]数组指称在i个手机的情况下，在第j层最坏情况的尝试次数
>
>     - 则情况一：dp\[i][j] = dp\[i][j-k]+1
>     - 情况二：dp\[i][j] = dp\[i-1][k-1]+1
>     - 由于我们运气很背，那么我们应该选取的是两个区间内最大次数的情况
>
>   - **归纳出**
>
>     f（n，k）=min（ max（f(i-1,k-1) ，f(n-i,k) ） i取1-n任意数 ）+1
>
>   **简单总结**：怎么确定第一个手机在哪扔？每层都试试，哪层的最坏情况（max）最好（min），就去哪层扔
>
>   ==这句话理解起来可能有点困难，但是核心意思是要在最坏的情况这个目标下倒推出最好的策略这个背景条件。比如说假定我们已经知道了一种最佳策略，在第K层扔最佳，那么我们运气又最差，那肯定就是找两个分段内哪种需要尝试的次数最多就行了，这种思维的逆向转变可能是一开始卡住的地方==

### Code

```c++
#include <bits/stdc++.h>
using namespace std;

int main(int argc, char const *argv[])
{
    int dp[3][1020] = {0};
    for (size_t i = 1; i <= 1000; i++)
    {
        dp[1][i] = i;
    }
    for (size_t mobile_number = 2; mobile_number < 4; mobile_number++)
        for (size_t level = 1; level <= 1000; level++)
        {
            int maxWorseCase = INT_MAX;
            for (size_t k = 1; k <= level; k++)
            {
                maxWorseCase = min(max(dp[mobile_number - 1][k-1],dp[mobile_number][level-k])+1,maxWorseCase);
            }
            dp[mobile_number][level] = maxWorseCase;
        }
    cout << dp[3][1000];
    return 0;
}
```
